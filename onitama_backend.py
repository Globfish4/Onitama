import random as rdimport numpy as npfrom abc import ABC, abstractmethodclass Plateau(list):    def __init__(self, xmax, ymax, mode):        """        la Classe Plateau elle gère le jeu en général, les liens entre les différentes pieces et cartes, elle coordonne        les inputs des joueurs et la faisabilité des coups demandés        :param xmax: taille abscisse du plateau (souvent égale à 5)        :param ymax: taille ordonnée du plateau (souvent égale à 5)        :param mode: indicateur de si le mode est l'esprit du vent, sensei's path ou mode normal        """        super().__init__()        self.xmax = xmax        self.ymax = ymax        self.cartes = []        self.joueurs = []        self.mode = mode            def remplir_plateau_vanilla(self):        """        initialise le plateau avec les pions, les joueurs et les cartes        :return: nothing        """        if self.mode:            V = Esprit_vent(self)            self.append(V)        self.joueurs.append(Joueur(1))        self.joueurs.append(Joueur(2))        R1, R2 = Roi(0, 2, 1, self), Roi(4, 2, 2, self)        self.append(R1)        self.append(R2)        self.joueurs[0].pieces.append(R1)        self.joueurs[1].pieces.append(R2)        for k in range(4):            if k < 2:                p1, p2 = Pion(0, k, 1, self, k + 1), Pion(4, k, 2, self, 5 - k - 1)            elif k >= 2:                p1, p2 = Pion(0, k+1, 1, self, k + 1), Pion(4, k+1, 2, self, 5 - k - 1)            self.append(p1)            self.append(p2)            self.joueurs[0].pieces.append(p1)            self.joueurs[1].pieces.append(p2)    def choisir_cartes(self, cartes_liste, cartes_vent = [], n_vent = 0):        """        choisit aléatoirement les cartes en fonction du mode de jeu choisi        :param cartes_liste: la liste des cartes du mode normal (ou mode voie du maitre)        :param cartes_vent: la liste des cartes du mode esprit du vent        :param n_vent: "sous" mode du mode esprit du vent        :return: nothing        """        # initialise la liste des cartes        n = len(cartes_liste)        m = len(cartes_vent)        L, M = list(range(n)), list(range(m))        rd.shuffle(L) #renvoie un arrangement aleatoire de nombres entre 0 et 15        rd.shuffle(M)        if n_vent == 0:            for k in range(5):                self.cartes.append(cartes_liste[L[k]])        if n_vent == 1:            self.cartes.append(cartes_vent[M[0]])            for k in range(5 - n_vent):                self.cartes.append(cartes_liste[L[k]])        if n_vent == 2:            self.cartes.append(cartes_liste[L[0]])            self.cartes.append(cartes_vent[M[0]])            self.cartes.append(cartes_liste[L[1]])            self.cartes.append(cartes_vent[M[1]])            self.cartes.append(cartes_liste[L[2]])        if n_vent == 3:            self.cartes.append(cartes_liste[M[0]])            self.cartes.append(cartes_vent[M[1]])            self.cartes.append(cartes_liste[L[0]])            self.cartes.append(cartes_vent[M[2]])            self.cartes.append(cartes_liste[L[1]])        if n_vent == 4:            self.cartes.append(cartes_liste[L[0]])            for k in range(4):                self.cartes.append(cartes_vent[M[k]])        if n_vent == 5:            for k in range(5):                self.cartes.append(cartes_vent[M[k]])    def tour_joueur(self, joueur, piece, carte, i):        """        si le coup demandé par le joueur est validé, alors on échange les cartes et on modifie les coordonnées du pion        :param joueur: joueur en question        :param piece: int, indice de la piece jouée        :param carte: int, indice de la carte jouée        :param i: int, indice du mouvement de la carte joué        :return: un booléen indiquant si le déplacement a été effectué        """        move = self.cartes[carte].moves[i]  # array numpy du déplacement relatif du pion        coup_valide = joueur.pieces[piece].deplacer(move, joueur) #on check si le déplacement ne sort pas du terrain        if coup_valide:            self.cartes[carte], self.cartes[0] = self.cartes[0], self.cartes[carte] #échange des cartes        return coup_valide    def tour_joueur_vent(self, joueur, piece, carte, i, vent, quel_pion):        """        même fonction que tour_joueur mais appliquée au mode esprit du vent. elle prend en compte les cas ou la carte est        une carte normale ou alors une carte esprit du vent        :param joueur: le joueur en train de jouer        :param piece: le numéro de la piece choisie par le joueur        :param carte: le numéro de la carte choisie par le joueur        :param i: le numéro de déplacement choisi par le joueur        :param vent: le numéro de déplacement de l'esprit du vent choisi par le joueur        :param quel_pion: dans le cas d'une carte normale, quel_pion détermine si le joueur choisit de déplacer un de        ses pions ou alors l'esprit du vent        :return: un indicateur de si le coup a été exécuté ou non        """        move = self.cartes[carte].moves[i]        if self.cartes[carte].carte_vent: #si la carte est une carte vent            move_vent = self.cartes[carte].moves_esprit[vent]            coup_valide = joueur.pieces[piece].deplacer(move, joueur)            if coup_valide:                coup_valide = self[0].deplacer(move_vent, joueur)                if not coup_valide:                    joueur.pieces[piece].deplacer(-move, joueur)        else: #si la carte est une carte normale            if quel_pion == 0: #c'est un pion normal                coup_valide = joueur.pieces[piece].deplacer(move, joueur)            else: #c'est l'esprit du vent qu'on bouge avec la carte normale                coup_valide = self[0].deplacer(move, joueur)        if coup_valide:            self.cartes[carte], self.cartes[0] = self.cartes[0], self.cartes[carte]  # échange des cartes        return coup_valide    def check_tour(self, joueur, adversaire, piece):        """        vérifie si un pion adverse est pris, ou si une des conditions de victoire est achevée        :param joueur: Joueur        :param adversaire: Joueur adverse        :param piece: indice de la piece jouée par joueur        :return: un booléen indicateur de si une condition de victoire est achevée        """        joueur.prendre_pion(adversaire, piece)        victoire, maniere = joueur.condition_victoire(adversaire)        if victoire:            self.gagner(joueur.i_joueur, maniere)        return victoire    #peut-être pas nécessaire avec l'IHM    def gagner(self, i_joueur, i_victoire):        if i_victoire == 1:            msg = "par la voie de la pierre."        else:            msg = "par la voie du ruisseau."        print("Le joueur " + str(i_joueur) + " gagne " + msg)class Piece(ABC):    def __init__(self, abscisse, ordonnee, i_joueur, plateau):  # i_joueur = 1 ou 2        """        la classe piece permet d'instancier des objets piece, de les déplacer en respectant certaines conditions        (énoncées dans les règles du jeu)        :param abscisse: la position initiale de la piece        :param ordonnee: la position initiale de la piece        :param i_joueur: le numéro du joueur auquel la piece est associée        :param plateau: le Plateau dans lequel la piece est placée        """        self.__coords = np.array([abscisse, ordonnee])        self.i_joueur = i_joueur  # en gros titre de joueur 1 joueur 2        self._plateau = plateau        self._vivante = True    @property    def coords(self):        return self.__coords    @property    def x(self):        return self.__coords[0]    @property    def y(self):        return self.__coords[1]    @abstractmethod    def car(self):        pass    def new_coords(self, val, valid):        """        modifie les coordonnées de la piece en val, a condition que ces nouvelles coordonnées soient toujours dans        les limites du terrain et si elles ne se confondent pas avec les coordonnées de l'esprit du vent        :param val: les nouvelles coordonnées        :return: un indicateur (booléen) de si les coordonnées ont bien été modifiées        """        if not valid:            return valid        setx = val[0]        sety = val[1]        if val[0] < 0 and self._vivante: #vérification des limites du terrain            return False        if val[0] > self._plateau.xmax-1:            return False        if val[1] < 0 and self._vivante:            return False        if val[1] > self._plateau.ymax-1:            return False        if self.car() == "V": #si la piece est un esprit du vent            n = len(self._plateau)            for i in range(1, n):                if list(self._plateau[i].coords) == list(val):                    if self._plateau[i].car()[0] != "R":                        self._plateau[i].__coords, self.__coords = self.__coords, self._plateau[i].__coords                        return True                                                 else:                        return False           self.__coords = (setx, sety)        return True    def deplacer(self, move, joueur):  # applique new_coords au pion choisi par le déplacement choisi        """        deplacer permet de vérifier que le pion ne sort pas des limites du terrain, qu'il ne se cogne pas à un autre pion        du même joueur, et modifie les coordonnées du pion si tout est respecté        :param move: tuple du déplacement relatif        :param joueur: Joueur qui est en train de jouer        :param dep_vent:        :return: un booléen indicateur de si le changement de coordonnées a été réalisé ou non        """        coeff = 1        valid = True        if joueur.i_joueur == 2:            coeff = -1        new_coord = np.array([self.coords[0] - coeff * move[1], self.coords[1] + coeff*move[0]])        if list(new_coord) == list(self._plateau[0].coords):            valid = False #on empêche les pions de se placer sur la case de l'esprit        for k in joueur.pieces:            if list(k.coords) == list(new_coord) and (self.car() != "V"): #on check la collision entre deux pions du joueur                valid = False #valid devient faux s'il y a collision        if not self.new_coords(new_coord, valid):            valid = False #valid devient faux si le pion sort du terrain        return valid  # retourne un indicateur de si le travail est effectué ou nonclass Pion(Piece):    def __init__(self, abscisse, ordonnee, i_joueur, plateau, num_pion):        """        sous classe de piece        """        super().__init__(abscisse, ordonnee, i_joueur, plateau)        self.numero_pion = num_pion    def mourir(self):        """        change l'état du joueur et modifie ses coordonnées pour qu'il n'apparaisse plus dans le plateau        :return: nothing        """        self._vivante = False        self.new_coords((-1, -1), True)  # on pose le pion à l'extérieur du plateau (possible car son attribut _vivante est False)    def car(self):        return "P" + str(self.i_joueur) + "," + str(self.numero_pion)class Roi(Piece):    def __init__(self, abscisse, ordonnee, i_joueur, plateau, num_pion = 0):        """        sous classe de piece        """        super().__init__(abscisse, ordonnee, i_joueur, plateau)        self.numero_pion = num_pion    def mourir(self):        """        si le roi meurt, c'est une condition de victoire. cette fonction active une fonction de victoire        :return: nothing        """        self._vivante = False        self.new_coords((-1, -1), True)        if self.i_joueur == 1:            self._plateau.gagner(2, 1)        else:            self._plateau.gagner(1, 1)    def car(self):        return "R" + str(self.i_joueur)class Esprit_vent(Piece):    def __init__(self, plateau):        """        sous classe de piece, sa position initiale est fixe        """        super().__init__(2, 2, 0, plateau)    def car(self):        return "V"class Carte:    def __init__(self, name, moves, i_debut, moves_esprit=[], carte_vent=False):  # moves est la liste des vecteurs de déplacement de la carte        """        classe définissant les cartes du jeu comme objets.        :param name: string, nom de la carte        :param moves: liste donnant des tuples de déplacement possibles [selon x, selon y] du pion        :param i_debut: int cet attribut définit quel joueur joue en premier. Voir les règles du jeu        :param moves_esprit: dans le cas ou la carte est une carte esprit du vent, alors elle a une seconde liste de        tuples définissant les mouvements disponibles pour l'esprit du vent        :param carte_vent: booléen, un indicateur de si la carte est une carte esprit du vent. False par défaut        """        self.name = name        self.moves = moves  # contient des tuples de deplacement relatif        self.moves_esprit = moves_esprit        self.nb_deplacement_possible = len(self.moves)        self.nb_esprit = len(self.moves_esprit)        self.i_debut = i_debut        self.carte_vent = carte_vent                       class Joueur:    def __init__(self, i_joueur):        """        la classe Joueur permet de gérer les pions du joueur d'un point de vue général.        :param i_joueur: joueur un ou joueur deux        """        self.pieces = []        self.i_joueur = i_joueur    def perdre_pion(self, pion):  # pion est le numero du pion a faire perdre        self.pieces[pion].mourir()    def prendre_pion(self, other, piece):  # self prend un pion à l'autre joueur        """        regarde si le pion déplacé a atteint une case dans laquelle figurait un pion adverse, auquel cas        la fonction perdre_pion est déclenchée pour le joueur adverse        :param other: Joueur, adversaire        :param piece: int, piece déplacée        :return: nothing        """        for l in range(len(other.pieces)):            if list(self.pieces[piece].coords) == list(other.pieces[l].coords):                other.perdre_pion(l)                break    def condition_victoire(self, adversaire):        """        vérifie si une condition de victoire a été atteinte. Elle vérifie d'abord si le roi du joueur est positionné        sur le trone adverse, puis elle vérifie si le roi adverse est capturé.        :param adversaire: Joueur, l'adversaire de self        :return: tuple (booléen, int), le booléen indique si une condition de victoire est atteinte, l'int indique quelle        condition de victoire est atteinte        """        if list(self.pieces[0].coords) == list(np.array([4, 2])) and self.i_joueur == 1:            return True, 2        if list(self.pieces[0].coords) == list(np.array([0, 2])) and self.i_joueur == 2:            return True, 2        if not adversaire.pieces[0]._vivante:  # si le roi adverse est mort            return True, 1        return False, 0###cartes###cartes vanillatigre = Carte("tigre", [np.array([0, -2]), np.array([0, 1])], 2)dragon = Carte("dragon", [np.array([1, 1]), np.array([-1, 1]), np.array([-2, -1]), np.array([2, -1])], 1)grenouille = Carte("grenouille", [np.array([-1, -1]), np.array([-2, 0]), np.array([1, 1])], 1)lapin = Carte("lapin", [np.array([-1, 1]), np.array([1, -1]), np.array([2, 0])], 1)crabe = Carte("crabe", [np.array([-2, 0]), np.array([2, 0]), np.array([0, -1])], 2)elephant = Carte("elephant", [np.array([-1, 0]), np.array([1, 0]), np.array([-1, -1]), np.array([1, -1])], 1)oie = Carte("oie", [np.array([-1, 0]), np.array([1, 0]), np.array([-1, -1]), np.array([1, 1])], 2)coq = Carte("coq", [np.array([-1, 0]), np.array([-1, 1]), np.array([1, 0]), np.array([1, -1])], 1)singe = Carte("singe", [np.array([1, -1]), np.array([-1, 1]), np.array([-1, -1]), np.array([1, 1])], 2)mante = Carte("mante", [np.array([-1, -1]), np.array([1, -1]), np.array([0, 1])], 1)cheval = Carte("cheval", [np.array([-1, 0]), np.array([0, -1]), np.array([0, 1])], 1)boeuf = Carte("boeuf", [np.array([0, -1]), np.array([1, 0]), np.array([0, 1])], 1)grue = Carte("grue", [np.array([0, -1]), np.array([-1, 1]), np.array([1, 1])], 2)sanglier = Carte("sanglier", [np.array([-1, 0]), np.array([1, 0]), np.array([0, -1])], 1)anguille = Carte("anguille", [np.array([-1, -1]), np.array([-1, 1]), np.array([1, 0])], 2)cobra = Carte("cobra", [np.array([-1, 0]), np.array([1, -1]), np.array([1, 1])], 2)##carte sensei pathpanda = Carte("panda", [np.array([0, -1]), np.array([1, -1]), np.array([-1, 1])], 1)renard = Carte("renard", [np.array([1, 0]), np.array([1, -1]), np.array([1, 1])], 1)ours = Carte("ours", [np.array([-1, -1]), np.array([0, -1]), np.array([1, 1])], 2)chien = Carte("chien", [np.array([-1, 0]), np.array([-1, 1]), np.array([-1, -1])], 2)tanuki = Carte("tanuki",[np.array([0, -1]), np.array([-1, 1]), np.array([2, -1])], 2)zibeline = Carte("zibeline", [np.array([-2, 0]), np.array([-1, 1]), np.array([1, -1])], 2)iguane = Carte("iguane", [np.array([0, -1]), np.array([-2, -1]), np.array([1, 1])], 1)loutre = Carte("loutre", [np.array([-1, -1]), np.array([0, 2]), np.array([1, 1])], 1)souris = Carte("souris", [np.array([0, -1]), np.array([1, 0]), np.array([-1, 1])], 2)serpent_de_mer = Carte("serpent_de_mer", [np.array([0, -1]), np.array([2, 0]), np.array([-1, 1])], 2)rat = Carte("rat", [np.array([0, -1]), np.array([-1, 0]), np.array([1, 1])], 1)vipere = Carte("vipere", [np.array([0, -1]), np.array([-2, 0]), np.array([1, 1])], 1)phenix = Carte("phenix", [np.array([-2, 0]), np.array([2, 0]), np.array([-1, -1]), np.array([1, -1])], 2)kirin = Carte("kirin", [np.array([-1, -2]), np.array([1, -2]), np.array([0, 2])], 1)tortue = Carte("tortue", [np.array([-2, 0]), np.array([2, 0]), np.array([-1, 1]), np.array([1, 1])], 1)girafe = Carte("girafe", [np.array([-2, -1]), np.array([2, -1]), np.array([0, 1])], 2)##carte esprit du ventaigle = Carte("aigle", [np.array([-1, -1]), np.array([1, -1])], 1, [np.array([-2, -2]), np.array([2, -2])], True)chauve_souris = Carte("chauve_souris", [np.array([0, -1]), np.array([0, 1])], 2, [np.array([-2, -1]), np.array([-1, -1]), np.array([1, -1]), np.array([2, -1])], True)lion = Carte("lion", [np.array([-1, 1]), np.array([1, -1])], 1, [np.array([0, -1]), np.array([0, -2])], True)pieuvre = Carte("pieuvre", [np.array([-1, -1]), np.array([1, 1])], 2, [np.array([0, -1]), np.array([1, 0]), np.array([1, 1]), np.array([0, 1]), np.array([-1, 1]), np.array([-1, 0])], True)scorpion = Carte("scorpion", [np.array([1, -1]), np.array([1, 1])], 2, [np.array([-2, -1]), np.array([-1, -2]), np.array([1, -2]), np.array([2, -1])], True)faucon = Carte("faucon", [np.array([-1, -1]), np.array([-1, 1])], 2, [np.array([-2, -1]), np.array([2, -1]), np.array([2, 0]), np.array([-2, 0])], True)araignee = Carte("araignee", [np.array([1, -1]), np.array([0, 1])], 1, [np.array([-1, -1]), np.array([0, -1]), np.array([1, -1]), np.array([0, 1])], True)rhinoceros = Carte("rhinoceros", [np.array([-1, -1]), np.array([0, 1])], 1, [np.array([0, -1]), np.array([1, -1]), np.array([2, 0]), np.array([-2, 0]), np.array([-1, -1])], True)cartes_liste = [tigre, dragon, grenouille, lapin, crabe, elephant, oie, coq, singe, mante, cheval, boeuf, grue, sanglier, anguille, cobra]cartes_vent_liste = [aigle, chauve_souris, lion, pieuvre, scorpion, faucon, araignee, rhinoceros]cartes_sp_liste = [panda, renard, ours, chien, tanuki, zibeline, iguane, loutre, souris, serpent_de_mer, rat, vipere, phenix, kirin, tortue, girafe]if __name__ == "__main__":    pass